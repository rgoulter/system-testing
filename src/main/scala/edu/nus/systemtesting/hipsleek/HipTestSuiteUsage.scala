package edu.nus.systemtesting.hipsleek

import java.io.PrintWriter
import java.nio.file.Path
import java.nio.file.Paths
import edu.nus.systemtesting.testsuite.TestSuite
import edu.nus.systemtesting.testsuite.TestSuiteResult
import edu.nus.systemtesting.TestCase
import edu.nus.systemtesting.TestCaseBuilder

/** Auto generated by [[SuiteGenerator]], and [[RunFastTests]].
  * Generated from revision 79da9697f0c2 of `run-fast-tests.pl`.
  */
class HipTestSuiteUsage(
    projDir: Path,
    significantTime: Long,
    timeout: Int,
    revision : String,
    examplesDir: Path = Paths.get("examples/working/hip"),
    command: Path = Paths.get("hip"))
    extends ConstructHipTests {
  def test(cmd: Path,
           file: String,
           args: String,
           expectedOutput: String): HipTestCase =
    (new TestCaseBuilder
       inProjectDir projDir
       runCommand cmd
       withCorpus examplesDir
       onFile Paths.get(file)
       withArguments args
       checkAgainst expectedOutput
       timeoutAfter timeout)

  def run(): TestSuiteResult = {
    val tests =
      ArrayTests ++
//      HipTrTests ++
      InfinityTests ++
      CoqinfTests ++
      ImmTests ++
      ImmfieldTests ++
      MemTests ++
      HipBagaTests ++
      HipTests ++
      HipLongModTests ++
      HipBarrTests ++
      SaTests ++
      HipVpermTests ++
      ParahipTests ++
      HipThreadsTests ++
      HipVeribsyncTests ++
      BagsTests ++
      TermTests ++
      ListsTests

    val suite = new TestSuite(tests, revision, significantTime)
    val suiteResult = suite.runAllTests

    suiteResult
  }

  val ArrayTests = List(
    test(command, "arr_at.java", "", "main: SUCCESS"),
    test(command, "arr_binarysearch.java", "", "binary_search: SUCCESS"),
    test(command, "arr_search_decrease_less_than_two.java", "", "searchzero: FAIL"),
    test(command, "arr_bubblesort.java", "", "bubblesort: SUCCESS, bubble: SUCCESS"),
    test(command, "arr_bubblesort_perm.java", "", "bubblesort: SUCCESS, bubble: SUCCESS"),
    test(command, "arr_double.java", "", "doublearr: SUCCESS"),
    test(command, "arr_extract_nonzeros.java", "", "copy_nonzeros: SUCCESS, count_nonzeros: SUCCESS, extract_nonzeros: SUCCESS"),
    test(command, "arr_init.java", "", "zinit: SUCCESS"),
    test(command, "arr_insertsort.java", "", "insertelm: SUCCESS, insertion_sort: SUCCESS"),
    test(command, "arr_insertsort_perm.java", "", "insertelm: SUCCESS, insertion_sort: SUCCESS"),
    test(command, "arr_invert.java", "", "Invert: SUCCESS, InvertHelper: SUCCESS"),
    test(command, "arr_max.java", "", "max_value_of_array: SUCCESS"),
    test(command, "arr_mergesort.java", "", "merge_sorted_arrays: SUCCESS, copy_array: SUCCESS, merge_sort: SUCCESS"),
    test(command, "arr_new_exp.java", "", "main: SUCCESS"),
    test(command, "arr_nqueens.java", "", "nQueens: SUCCESS, nQueensHelper: SUCCESS, nQueensHelperHelper: SUCCESS"),
    test(command, "arr_qsort.java", "", "arraypart: SUCCESS, qsort: SUCCESS"),
    test(command, "arr_rev.java", "", "arrayrev: SUCCESS"),
    test(command, "arr_selectionsort.java", "", "array_index_of_max: SUCCESS, selection_sort: SUCCESS"),
    test(command, "arr_selectionsort_perm.java", "", "array_index_of_max: SUCCESS, selection_sort: SUCCESS"),
    test(command, "arr_sparse.java", "--imm", "create: SUCCESS, get: SUCCESS, setsa: SUCCESS"),
    test(command, "arr_sum.java", "", "sigmaright: SUCCESS, sigmaleft: SUCCESS")
  )

//  val HipTrTests = List(
//    test(command, "trees.ss", "insert", "")
//  )

  val InfinityTests = List(
    test(command, "inflist.ss", "--en-inf", "remove: SUCCESS, append: SUCCESS"),
    test(command, "infll_take.ss", "--en-inf", "take: SUCCESS"),
    test(command, "inftree.ss", "--en-inf", "count: SUCCESS"),
    test(command, "stream.ss", "--en-inf", "zip: SUCCESS"),
    test(command, "bst-inf.ss", "--en-inf", "delete: SUCCESS, remove_min: SUCCESS"),
    test(command, "inf-selsort.ss", "--en-inf", "find_min: SUCCESS, delete_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "inf-ins.ss", "--dsd --en-inf", "insert: SUCCESS"),
    test(command, "inf-sel.ss", "--dsd --en-inf", "find_min: SUCCESS, delete_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "bubble-inf.ss", "--en-inf", "id2: SUCCESS, id3: SUCCESS, bubble: SUCCESS, bsort: SUCCESS"),
    test(command, "heaps-inf.ss", "--en-inf", "insert: SUCCESS, deleteoneel: SUCCESS, deleteone: SUCCESS, deletemax: SUCCESS"),
    test(command, "merge-inf.ss", "--en-inf --en-disj-compute", "merge: SUCCESS")
  )

  val CoqinfTests = List(
    test(command, "inflist.ss", "--en-inf", "remove: SUCCESS, append: SUCCESS, fail_remove: FAIL"),
    test(command, "infll_take.ss", "--en-inf", "take: SUCCESS"),
    test(command, "inftree.ss", "--en-inf", "count: SUCCESS"),
    test(command, "stream.ss", "--en-inf", "zip: SUCCESS"),
    test(command, "bst-inf.ss", "--en-inf --eps --etcsu2 --etcsu3", "delete: SUCCESS, remove_min: SUCCESS"),
    test(command, "inf-selsort.ss", "--en-inf --etcsu2 --etcsu3", "find_min: SUCCESS, delete_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "inf-ins.ss", "--dsd --en-inf", "insert: SUCCESS"),
    test(command, "inf-sel.ss", "--dsd --en-inf --etcsu2 --etcsu3", "find_min: SUCCESS, delete_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "bubble-inf.ss", "--en-inf", "id2: SUCCESS, id3: SUCCESS, bubble: SUCCESS, bsort: SUCCESS"),
    test(command, "merge-inf.ss", "--en-inf --en-disj-compute --etcsu2 --etcsu3", "merge: SUCCESS")
  )

  val ImmTests = List(
    test(command, "bigint.ss", "--imm -tp redlog", "clone: SUCCESS, int_value: SUCCESS, bigint_of: SUCCESS, add_one_digit: SUCCESS, add_c: SUCCESS, add: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS, sub: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult: SUCCESS, is_zero: SUCCESS, is_equal: SUCCESS, compare2: SUCCESS, compare_int: SUCCESS, div_with_remainder: SUCCESS"),
    test(command, "bigint_imm.ss", "--imm -tp redlog", "clone: SUCCESS, int_value: SUCCESS, bigint_of: SUCCESS, add_one_digit: SUCCESS, test: SUCCESS, add_c: SUCCESS, add: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS, sub: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult2: SUCCESS, is_zero: SUCCESS, is_equal: SUCCESS, compare2: SUCCESS, compare_int: SUCCESS, div_with_remainder: SUCCESS"),
    test(command, "bigint_imm-star.ss", "--imm -tp redlog", "clone: SUCCESS, int_value: SUCCESS, bigint_of: SUCCESS, add_one_digit: SUCCESS, add_c: SUCCESS, add: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS, sub: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult: SUCCESS, is_zero: SUCCESS, is_equal: SUCCESS, compare2: SUCCESS, compare_int: SUCCESS, div_with_remainder: SUCCESS"),
    test(command, "bigint-tight.ss", "--imm -tp redlog", "clone: SUCCESS, int_value: SUCCESS, bigint_of: SUCCESS, add_one_digit: SUCCESS, add_c: SUCCESS, add: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS, sub: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult: SUCCESS, is_zero: SUCCESS, is_equal: SUCCESS, compare2: SUCCESS, compare_int: SUCCESS, div_with_remainder: SUCCESS"),
    test(command, "bigint-tight-imm.ss", "--imm -tp redlog", "clone: SUCCESS, int_value: SUCCESS, bigint_of: SUCCESS, add_one_digit: SUCCESS, test: SUCCESS, add_c: SUCCESS, add: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS, sub: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult: SUCCESS, is_zero: SUCCESS, is_equal: SUCCESS, compare2: SUCCESS, compare_int: SUCCESS, div_with_remainder: SUCCESS"),
    test(command, "bigint-tight-imm-star.ss", "--imm -tp redlog", "clone: SUCCESS, int_value: SUCCESS, bigint_of: SUCCESS, add_one_digit: SUCCESS, add_c: SUCCESS, add: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS, sub: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult: SUCCESS, is_zero: SUCCESS, is_equal: SUCCESS, compare2: SUCCESS, compare_int: SUCCESS, div_with_remainder: SUCCESS"),
    test(command, "append_imm.ss", "--imm", "append: SUCCESS"),
    test(command, "kara.ss", "--imm -tp redlog", "karatsuba_mult: SUCCESS"),
    test(command, "kara-imm-star.ss", "--imm -tp redlog", "karatsuba_mult: SUCCESS"),
    test(command, "kara-imm-conj.ss", "--imm -tp redlog", "karatsuba_mult: SUCCESS"),
    test(command, "ll_imm.ss", "--imm", "length: SUCCESS, append: SUCCESS, sumN: SUCCESS, set_next: SUCCESS, get_next_next: SUCCESS, get_next: SUCCESS")
  )

  val ImmfieldTests = List(
    test(command, "imspd.ss", "-tp oc --field-imm --etcsu1", "check_pass: SUCCESS, login: SUCCESS"),
    test(command, "getset.ss", "-tp oc --field-imm --etcsu1", "sset: SUCCESS, get: SUCCESS, setA: SUCCESS, getA: SUCCESS, non_negative: SUCCESS"),
    test(command, "bigint.ss", "-tp redlog --field-imm --etcsu1", "clone: SUCCESS, add_one_digit: SUCCESS, add_c: SUCCESS, add: SUCCESS, div_with_remainder: SUCCESS, bigint_of: SUCCESS, compare_int: SUCCESS, is_zero: SUCCESS, compare2: SUCCESS, int_value: SUCCESS, mult_c: SUCCESS, shift_left: SUCCESS, mult: SUCCESS, sub_one_digit: SUCCESS, sub_c: SUCCESS"),
    test(command, "insertion_simple.ss", "-tp oc --field-imm --etcsu1", "insert: SUCCESS"),
    test(command, "schorr-waite-list.ss", "-tp om --field-imm --etcsu1", "lscan: SUCCESS"),
    test(command, "sll.ss", "-tp oc --field-imm --etcsu1", "delete: SUCCESS, get_tail: SUCCESS, insert: SUCCESS, insert2: SUCCESS")
  )

  val MemTests = List(
    test(command, "dag.ss", "-tp om --mem --ramify", "mark: SUCCESS, mark2: SUCCESS"),
    test(command, "dag_values.ss", "-tp om --mem --ramify", "mark: SUCCESS, mark2: SUCCESS"),
    test(command, "dag_values_infer.ss", "-tp om --mem --ramify --infer-mem", "mark: SUCCESS, mark2: SUCCESS"),
    test(command, "graph.ss", "-tp om --mem --ramify", "mark: SUCCESS, mark2: SUCCESS"),
    test(command, "graph_values.ss", "-tp om --mem --ramify", "mark: SUCCESS, mark2: SUCCESS"),
    test(command, "graph_values_infer.ss", "-tp om --mem --ramify --infer-mem", "mark: SUCCESS, mark2: SUCCESS"),
    test(command, "dag_1.ss", "-tp om --mem --ramify", "mark: SUCCESS"),
    test(command, "dag_1_ramify.ss", "-tp om --mem --ramify", "mark: SUCCESS"),
    test(command, "graph_1.ss", "-tp om --mem --ramify", "mark: SUCCESS"),
    test(command, "graph_1_ramify.ss", "-tp om --mem --ramify", "mark: SUCCESS"),
    test(command, "dag_copy.ss", "-tp om --mem --ramify", "copy_dag: SUCCESS"),
    test(command, "garbage_collector.ss", "-tp om --mem --ramify", "mark: SUCCESS, sweep: SUCCESS, collect: SUCCESS"),
    test(command, "garbage_collector_values.ss", "-tp om --mem --ramify", "mark: SUCCESS, sweep: SUCCESS, collect: SUCCESS"),
    test(command, "garbage_collector_values_infer.ss", "-tp om --mem --ramify --infer-mem", "mark: SUCCESS, sweep: SUCCESS, collect: SUCCESS"),
    test(command, "llsortll.ss", "-tp om --mem --eps", "overlaid_insert: SUCCESS, delete2: SUCCESS, insert2: SUCCESS, get_tail: SUCCESS, insertion_sort: SUCCESS, id: SUCCESS"),
    test(command, "infer_llsortll.ss", "-tp om --mem --eps --infer-mem", "overlaid_insert: SUCCESS, delete2: SUCCESS, insert2: SUCCESS, get_tail: SUCCESS, insertion_sort: SUCCESS, id: SUCCESS"),
    test(command, "lltree.ss", "-tp om --mem", "move_request: SUCCESS"),
    test(command, "infer_lltree.ss", "-tp om --mem --infer-mem", "move_request: SUCCESS"),
    test(command, "lltree2.ss", "-tp om --mem --eps", "move_request: SUCCESS"),
    test(command, "infer_lltree2.ss", "-tp om --mem --eps --infer-mem", "move_request: SUCCESS"),
    test(command, "nodell.ss", "-tp om --mem --ramify", "delete_cache: SUCCESS, delete: SUCCESS, add_L: SUCCESS, caching: SUCCESS, add_in: SUCCESS, find: SUCCESS"),
    test(command, "nodell_infer.ss", "-tp om --mem --ramify --infer-mem", "delete_cache: SUCCESS, delete: SUCCESS, add_L: SUCCESS, caching: SUCCESS, add_in: SUCCESS, find: SUCCESS"),
    test(command, "pll.ss", "-tp om --mem", "length: SUCCESS, sum: SUCCESS"),
    test(command, "pll_ramify.ss", "-tp om --mem --ramify", "length: SUCCESS, sum: SUCCESS"),
    test(command, "pll_infer.ss", "-tp om --mem --infer-mem", "length: SUCCESS, sum: SUCCESS"),
    test(command, "pll_ramify_infer.ss", "-tp om --mem --ramify --infer-mem", "length: SUCCESS, sum: SUCCESS"),
    test(command, "doubly_circular_list.ss", "-tp om --mem", "insert_node_dcll: SUCCESS, insert_lln: SUCCESS, insert_llt: SUCCESS, insert_dcll: SUCCESS"),
    test(command, "infer_doubly_circular_list.ss", "-tp om --mem --infer-mem", "insert_node_dcll: SUCCESS, insert_lln: SUCCESS, insert_llt: SUCCESS, insert_dcll: SUCCESS"),
    test(command, "process_schedular.ss", "-tp om --mem", "insert_process: SUCCESS, insert_rll: SUCCESS, insert_pll: SUCCESS, insert_sll: SUCCESS"),
    test(command, "process_schedular_ramify.ss", "-tp om --mem --ramify", "insert_process: SUCCESS, insert_rll: SUCCESS, insert_pll: SUCCESS, insert_sll: SUCCESS"),
    test(command, "ramified-cells.ss", "--mem --ramify", "ex0: SUCCESS, ex1: SUCCESS, mark: SUCCESS"),
    test(command, "ramified-pairs.ss", "--mem --ramify", "mark: SUCCESS"),
    test(command, "jsvarstore.ss", "--mem --ramify", "ex1: SUCCESS"),
    test(command, "graph_spanning.ss", "-tp om --mem --ramify --eps", "spanning: SUCCESS"),
    test(command, "graph_spanning_infer.ss", "-tp om --mem --ramify --eps --infer-mem", "spanning: SUCCESS")
  )

  val HipBagaTests = List(
    test(command, "eps.ss", "--use-baga", "get_next: SUCCESS, get_next_next: SUCCESS"),
    test(command, "append.ss", "--use-baga", "append: SUCCESS"),
    test(command, "append-tail.ss", "--use-baga", "append: SUCCESS"),
    test(command, "avl-bind.ss", "--use-baga", "height: SUCCESS, rotate_left: SUCCESS, rotate_right: SUCCESS, get_max: SUCCESS, rotate_double_left: SUCCESS, rotate_double_right: SUCCESS, build_avl1: SUCCESS, build_avl2: SUCCESS, insert: SUCCESS"),
    test(command, "avl.ss", "--use-baga", "height: SUCCESS, rotate_left: SUCCESS, rotate_right: SUCCESS, get_max: SUCCESS, rotate_double_left: SUCCESS, rotate_double_right: SUCCESS, build_avl1: SUCCESS, build_avl2: SUCCESS, insert: SUCCESS, insert_inline: SUCCESS"),
    test(command, "avl-orig-2.ss", "--use-baga", "height: SUCCESS, get_max: SUCCESS, insert: SUCCESS, double_left_child: SUCCESS, double_right_child: SUCCESS, rotate_left_child: SUCCESS, rotate_right_child: SUCCESS"),
    test(command, "avl-orig3.ss", "--use-baga", "height: SUCCESS, get_max: SUCCESS, insert: SUCCESS, double_left_child: SUCCESS, double_right_child: SUCCESS, rotate_left_child: SUCCESS, rotate_right_child: SUCCESS"),
    test(command, "bll.ss", "--use-baga", "insert: SUCCESS, delete: SUCCESS"),
    test(command, "bubble.ss", "--use-baga", "id2: SUCCESS, id3: SUCCESS, bubble: SUCCESS, bsort: SUCCESS"),
    test(command, "cll.ss", "--use-baga", "test: SUCCESS, insert: SUCCESS, count_rest: SUCCESS, count: SUCCESS, delete: SUCCESS"),
    test(command, "complete.ss", "--use-baga", "maxim: SUCCESS, minim: SUCCESS, height: SUCCESS, min_height: SUCCESS, insert: SUCCESS"),
    test(command, "dll.ss", "--use-baga", "insert: SUCCESS, delete: SUCCESS, delete1: SUCCESS, test_del: SUCCESS, test_del2: SUCCESS, test_fold: SUCCESS, append: SUCCESS, append1: SUCCESS, f1: SUCCESS, f2: SUCCESS"),
    test(command, "heaps.ss", "--use-baga", "insert: SUCCESS, deleteoneel: SUCCESS, deleteone: SUCCESS, ripple: SUCCESS, deletemax: SUCCESS"),
    test(command, "insertion.ss", "--use-baga", "insert: SUCCESS, insertion_sort: SUCCESS"),
    test(command, "ll.ss", "--use-baga", "append: SUCCESS, ret_first: SUCCESS, get_next: SUCCESS, set_next: SUCCESS, set_null: SUCCESS, get_next_next: SUCCESS, insert: SUCCESS, delete: SUCCESS, create_list: SUCCESS, reverse: SUCCESS"),
    test(command, "merge.ss", "--use-baga", "count: SUCCESS, split_func: SUCCESS, merge_sort: SUCCESS, merge: SUCCESS, insert: SUCCESS"),
    test(command, "perfect.ss", "--use-baga", "simple_insert: SUCCESS, create: SUCCESS, maxim: SUCCESS, height: SUCCESS, insert: SUCCESS"),
    test(command, "qsort.ss", "--use-baga", "partition: SUCCESS, append_bll: SUCCESS, qsort: SUCCESS"),
    test(command, "selection.ss", "--use-baga", "find_min: SUCCESS, delete_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "sll.ss", "--use-baga", "insert: SUCCESS, insert2: SUCCESS, delete: SUCCESS, get_tail: SUCCESS, insertion_sort: SUCCESS, id: SUCCESS"),
    test(command, "trees.ss", "--use-baga", "append: SUCCESS, count: SUCCESS, flatten: SUCCESS, insert: SUCCESS, remove_min: SUCCESS, delete: SUCCESS"),
    test(command, "rb.ss", "--use-baga", "rotate_case_3: SUCCESS, case_2: SUCCESS, rotate_case_3r: SUCCESS, case_2r: SUCCESS, is_red: SUCCESS, is_black: SUCCESS, del_6: SUCCESS, del_6r: SUCCESS, del_5: SUCCESS, del_5r: SUCCESS, del_4: SUCCESS, del_4r: SUCCESS, del_3: SUCCESS, del_3r: SUCCESS, del_2: SUCCESS, remove_min: SUCCESS, del: SUCCESS, insert: SUCCESS"),
    test(command, "global-ll.ss", "--use-baga", "insert_rec: SUCCESS, delete_last_rec: SUCCESS, insert: SUCCESS, delete_last: SUCCESS, main: SUCCESS"),
    test(command, "modular_examples/dll-modular.ss", "--overeps --use-baga", "append: SUCCESS, append1: SUCCESS, append2: SUCCESS, delete: SUCCESS, delete1: SUCCESS, f1: SUCCESS, f2: SUCCESS, insert: SUCCESS, test_del: SUCCESS, test_del2: SUCCESS, test_fold: SUCCESS"),
    test(command, "modular_examples/selection-modular.ss", "--overeps --lda --use-baga", "delete_min: SUCCESS, find_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "modular_examples/qsort-modular.ss", "--overeps --lda --use-baga", "append_bll: SUCCESS, partition: SUCCESS, qsort: SUCCESS")
  )

  val HipTests = List(
    test(command, "eps.ss", "", "get_next: SUCCESS, get_next_next: SUCCESS"),
    test(command, "append.ss", "", "append: SUCCESS"),
    test(command, "append-tail.ss", "", "append: SUCCESS"),
    test(command, "avl-bind.ss", "", "height: SUCCESS, rotate_left: SUCCESS, rotate_right: SUCCESS, get_max: SUCCESS, rotate_double_left: SUCCESS, rotate_double_right: SUCCESS, build_avl1: SUCCESS, build_avl2: SUCCESS, insert: SUCCESS"),
    test(command, "avl.ss", "", "height: SUCCESS, rotate_left: SUCCESS, rotate_right: SUCCESS, get_max: SUCCESS, rotate_double_left: SUCCESS, rotate_double_right: SUCCESS, build_avl1: SUCCESS, build_avl2: SUCCESS, insert: SUCCESS, insert_inline: SUCCESS"),
    test(command, "avl-orig-2.ss", "", "height: SUCCESS, get_max: SUCCESS, insert: SUCCESS, double_left_child: SUCCESS, double_right_child: SUCCESS, rotate_left_child: SUCCESS, rotate_right_child: SUCCESS"),
    test(command, "avl-orig3.ss", "", "height: SUCCESS, get_max: SUCCESS, insert: SUCCESS, double_left_child: SUCCESS, double_right_child: SUCCESS, rotate_left_child: SUCCESS, rotate_right_child: SUCCESS"),
    test(command, "bll.ss", "", "insert: SUCCESS, delete: SUCCESS"),
    test(command, "bubble.ss", "", "id2: SUCCESS, id3: SUCCESS, bubble: SUCCESS, bsort: SUCCESS"),
    test(command, "cll.ss", "", "test: SUCCESS, insert: SUCCESS, count_rest: SUCCESS, count: SUCCESS, delete: SUCCESS"),
    test(command, "complete.ss", "", "maxim: SUCCESS, minim: SUCCESS, height: SUCCESS, min_height: SUCCESS, insert: SUCCESS"),
    test(command, "dll.ss", "", "insert: SUCCESS, delete: SUCCESS, delete1: SUCCESS, test_del: SUCCESS, test_del2: SUCCESS, test_fold: SUCCESS, append: SUCCESS, append1: SUCCESS, f1: SUCCESS, f2: SUCCESS"),
    test(command, "heaps.ss", "", "insert: SUCCESS, deleteoneel: SUCCESS, deleteone: SUCCESS, ripple: SUCCESS, deletemax: SUCCESS"),
    test(command, "insertion.ss", "", "insert: SUCCESS, insertion_sort: SUCCESS"),
    test(command, "ll.ss", "", "append: SUCCESS, ret_first: SUCCESS, get_next: SUCCESS, set_next: SUCCESS, set_null: SUCCESS, get_next_next: SUCCESS, insert: SUCCESS, delete: SUCCESS, create_list: SUCCESS, reverse: SUCCESS"),
    test(command, "merge.ss", "", "count: SUCCESS, split_func: SUCCESS, merge_sort: SUCCESS, merge: SUCCESS, insert: SUCCESS"),
    test(command, "perfect.ss", "", "simple_insert: SUCCESS, create: SUCCESS, maxim: SUCCESS, height: SUCCESS, insert: SUCCESS"),
    test(command, "qsort.ss", "", "partition: SUCCESS, append_bll: SUCCESS, qsort: SUCCESS"),
    test(command, "selection.ss", "", "find_min: SUCCESS, delete_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "sll.ss", "", "insert: SUCCESS, insert2: SUCCESS, delete: SUCCESS, get_tail: SUCCESS, insertion_sort: SUCCESS, id: SUCCESS"),
    test(command, "trees.ss", "", "append: SUCCESS, count: SUCCESS, flatten: SUCCESS, insert: SUCCESS, remove_min: SUCCESS, delete: SUCCESS"),
    test(command, "rb.ss", "", "rotate_case_3: SUCCESS, case_2: SUCCESS, rotate_case_3r: SUCCESS, case_2r: SUCCESS, is_red: SUCCESS, is_black: SUCCESS, del_6: SUCCESS, del_6r: SUCCESS, del_5: SUCCESS, del_5r: SUCCESS, del_4: SUCCESS, del_4r: SUCCESS, del_3: SUCCESS, del_3r: SUCCESS, del_2: SUCCESS, remove_min: SUCCESS, del: SUCCESS, insert: SUCCESS"),
    test(command, "global1.ss", "", "increase: SUCCESS"),
    test(command, "global2.ss", "", "increase: SUCCESS"),
    test(command, "global3.ss", "", "increase: SUCCESS, increase_n: SUCCESS"),
    test(command, "global4.ss", "", "increase_n: SUCCESS, main: SUCCESS"),
    test(command, "global5.ss", "", "increase: SUCCESS, decrease: SUCCESS"),
    test(command, "global-ll.ss", "", "insert_rec: SUCCESS, delete_last_rec: SUCCESS, insert: SUCCESS, delete_last: SUCCESS, main: SUCCESS"),
    test(command, "global-mutual-rec.ss", "", "decrease1: SUCCESS, decrease2: SUCCESS, main: SUCCESS"),
    test(command, "classic/classic1.ss", "", "foo1: SUCCESS, foo2: SUCCESS"),
    test(command, "classic/classic1.ss", "--classic", "foo1: FAIL, foo2: SUCCESS"),
    test(command, "classic/classic1a.ss", "", "foo1: SUCCESS, foo2: SUCCESS"),
    test(command, "classic/classic1a.ss", "--classic", "foo1: SUCCESS, foo2: FAIL"),
    test(command, "classic/classic2.ss", "", "foo1: FAIL, foo2: SUCCESS"),
    test(command, "classic/classic2a.ss", "", "foo1: SUCCESS, foo2: FAIL"),
    test(command, "classic/classic3.ss", "", "foo1: SUCCESS, foo2: SUCCESS"),
    test(command, "classic/classic3a.ss", "", "foo1: SUCCESS, foo2: SUCCESS"),
    test(command, "../../modular_examples/dll-modular.ss", "--overeps", "append: SUCCESS, append1: SUCCESS, append2: SUCCESS, delete: SUCCESS, delete1: SUCCESS, f1: SUCCESS, f2: SUCCESS, insert: SUCCESS, test_del: SUCCESS, test_del2: SUCCESS, test_fold: SUCCESS"),
    test(command, "../../modular_examples/selection-modular.ss", "--overeps --lda", "delete_min: SUCCESS, find_min: SUCCESS, selection_sort: SUCCESS"),
    test(command, "../../modular_examples/qsort-modular.ss", "--overeps --lda", "append_bll: SUCCESS, partition: SUCCESS, qsort: SUCCESS"),
    test(command, "vperm/ho_vperm_check.ss", "--ann-vp", "inc: SUCCESS, incCell: SUCCESS, test1: FAIL, test2: FAIL, test3: FAIL, test4: FAIL"),
    test(command, "vperm/task_decompose.ss", "--ann-vp", "inc: SUCCESS, creator: SUCCESS, joiner: SUCCESS, main: SUCCESS"),
    test(command, "parahip/cell.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "test: SUCCESS, test1: FAIL"),
    test(command, "parahip/cell-extreme-cases.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "test: FAIL, test2: FAIL, test3: FAIL, test4: FAIL"),
    test(command, "parahip/ordered-locking.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/unordered-locking.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: FAIL, main: SUCCESS"),
    test(command, "veribsync/hip-bperm1.ss", "--en-para -perm bperm -tp redlog", "destroyCellFail: FAIL, readCell: SUCCESS, testNewCell: SUCCESS, testNewCell2: SUCCESS, updateCell: SUCCESS, updateCellFail: FAIL"),
    test(command, "veribsync/barrier-static-consistency.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, main_fail: FAIL, participant: SUCCESS, participant1: SUCCESS, participant_fail: FAIL"),
    test(command, "veribsync/barrier-dynamic-exp3.ss", "--en-para -perm bperm -tp redlog", "main: FAIL, thread1: SUCCESS, thread2: SUCCESS, thread3: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp4.ss", "--en-para -perm bperm -tp redlog", "childthread1: SUCCESS, childthread2: SUCCESS, main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "conchip/mapreduce.ss", "-tp parahip --classic", "count_helper: SUCCESS, countList: SUCCESS, destroyList: SUCCESS, main: SUCCESS, mapper_helper: SUCCESS, mapper: SUCCESS, reducer1: SUCCESS, reducer2: SUCCESS"),
    test(command, "conchip/multi-join2.ss", "-tp parahip  -perm fperm --classic", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "conchip/latch-exp2.ss", "-tp parahip --classic", "main: FAIL, thread1: SUCCESS"),
    test(command, "conchip/deadpool.ss", "-tp parahip -perm fperm --classic", "destroyDeadPool: SUCCESS, forkHelper: SUCCESS, forkThreads: SUCCESS, joinHelper: SUCCESS, joinThreads: SUCCESS, main: SUCCESS, thread: SUCCESS")
  )

  val HipLongModTests = List(
    test(command, "../../modular_examples/sorted_list_modular.ss", "--overeps -tp om", "insert_first: SUCCESS, copy: SUCCESS, delete: SUCCESS, double_reverse: SUCCESS, insert: SUCCESS, insert_last: SUCCESS, merge: SUCCESS, reverse: SUCCESS"),
    test(command, "../../modular_examples/complete-modular.ss", "--overeps", "maxim: SUCCESS, height: SUCCESS, minim: SUCCESS, min_height: SUCCESS, insert: SUCCESS")
  )

  val HipBarrTests = List(
    test(command, "../tree_shares/thesis/video_ex1_th3.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "th1_loop: SUCCESS, th1: SUCCESS, th2_loop: SUCCESS, th2: SUCCESS, th3_loop: SUCCESS, th3: SUCCESS"),
    test(command, "../tree_shares/thesis/SIMD_ex1_v2_th3.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "controll: SUCCESS, control: SUCCESS, thl1: SUCCESS, th1: SUCCESS, thl2: SUCCESS, th2: SUCCESS, thl3: SUCCESS, th3: SUCCESS, thl4: SUCCESS, th4: SUCCESS"),
    test(command, "../tree_shares/thesis/SIMD_ex1_th1.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "controll: SUCCESS, control: SUCCESS, thl1: SUCCESS, th1: SUCCESS, thl2: SUCCESS, th2: SUCCESS"),
    test(command, "../tree_shares/thesis/PIPE_ex1_th5.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "controll: SUCCESS, thl5: SUCCESS, thl1: SUCCESS, thl2: SUCCESS, thl3: SUCCESS, thl4: SUCCESS"),
    test(command, "../tree_shares/thesis/MIXED_ex1_th4.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "ctl12: SUCCESS, ctl11: SUCCESS, starterc: SUCCESS, thl12: SUCCESS, thl22: SUCCESS, thl21: SUCCESS, thl11: SUCCESS, startert1: SUCCESS, startert2: SUCCESS, thl32: SUCCESS, thl31: SUCCESS, startert3: SUCCESS, thl42: SUCCESS, thl41: SUCCESS, startert4: SUCCESS"),
    test(command, "../tree_shares/thesis/MISD_ex2_th5.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "controll: SUCCESS, control: SUCCESS, thl: SUCCESS, th: SUCCESS, thl2: SUCCESS, th2: SUCCESS, thl3: SUCCESS, th3: SUCCESS, thl4: SUCCESS, th4: SUCCESS, thl5: SUCCESS, th5: SUCCESS"),
    test(command, "../tree_shares/thesis/MISD_ex1_th5.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "controll: SUCCESS, control: SUCCESS, thl: SUCCESS, th: SUCCESS"),
    test(command, "../tree_shares/thesis/barrier-weak.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "th1_loop: SUCCESS, th1: SUCCESS, th2_loop: SUCCESS, th2: SUCCESS"),
    test(command, "../tree_shares/thesis/barrier-strong.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "th1_loop: SUCCESS, th1: SUCCESS, th2_loop: SUCCESS, th2: SUCCESS"),
    test(command, "../tree_shares/thesis/barrier-paper.ss", "--eps --dis-field-imm --dis-precise-xpure -perm dperm", "th1_loop: SUCCESS, th1: SUCCESS, th2_loop: SUCCESS, th2: SUCCESS")
  )

  val SaTests = List(
    test(command, "ll-trav.c", "-validate infer/output/sa/ll-trav.cp", "foo: SUCCESS"),
    test(command, "ll-trav-1.c", "-validate infer/output/sa/ll-trav-1.cp", "foo: SUCCESS"),
    test(command, "ll-delete.ss", "-validate infer/output/sa/ll-delete.cp", "whiledel: SUCCESS"),
    test(command, "zip_paper_eq.c", "-validate infer/output/sa/zip_paper_eq.cp", "zip: SUCCESS"),
    test(command, "check-sll-head.c", "-validate infer/output/sa/check-sll-head.cp --pred-dis-seg", "foo: SUCCESS"),
    test(command, "skip2-list.c", "-validate infer/output/sa/skip2-list.cp --pred-en-equiv -tp z3", "skip0: SUCCESS, skip1: SUCCESS"),
    test(command, "skip3-list.c", "-validate infer/output/sa/skip3-list.cp --pred-en-equiv -tp z3", "skip0: SUCCESS, skip1: SUCCESS, skip2: SUCCESS"),
    test(command, "check-sorted.c", "-validate infer/output/sa/check-sorted.cp --sa-en-pure-field -tp z3", "check_sorted: SUCCESS"),
    test(command, "sll-insertsort.c", "-validate infer/output/sa/sll-insertsort.cp -tp z3", "insert: SUCCESS"),
    test(command, "cll.c", "-validate infer/output/sa/cll.cp -tp z3  --pred-en-dangling", "count_rest: SUCCESS"),
    test(command, "check-cll.c", "-validate infer/output/sa/check-cll.cp -tp z3  --pred-en-dangling", "check_csll: SUCCESS"),
    test(command, "sll-01-slls.c", "-validate infer/output/sa/sll-01-slls.cp -tp z3  --pred-en-dangling", "helper: SUCCESS"),
    test(command, "sll-dll.c", "-validate infer/output/sa/sll-dll.cp -tp z3  --pred-en-equiv", "paper_fix: SUCCESS"),
    test(command, "check-dll.c", "-validate infer/output/sa/check-dll.cp -tp z3", "check_dll: SUCCESS"),
    test(command, "check-cllclls.c", "-validate infer/output/sa/check-cllclls.cp -tp z3 --pred-en-equiv", "check_csll: SUCCESS, check_csll_outer: SUCCESS"),
    test(command, "check-cdll5clls.c", "-validate infer/output/sa/check-cdll5clls.cp -tp z3 --pred-en-equiv", "check_csll: SUCCESS, check_cdll_out1: SUCCESS"),
    test(command, "check-cdllcllsx2.c", "-validate infer/output/sa/check-cdllcllsx2.cp -tp z3 --pred-en-equiv", "check_csll: SUCCESS, check_csll_outer1: SUCCESS, check_cdll_outer2: SUCCESS"),
    test(command, "dll-append_paper.c", "-validate infer/output/sa/dll-append_paper.cp -tp z3", "dll_append: SUCCESS"),
    test(command, "bt-search-2.c", "-validate infer/output/sa/bt-search-2.cp -tp z3 --pred-unify-post", "search: SUCCESS"),
    test(command, "tll.c", "-validate infer/output/sa/tll.cp -tp z3 --pred-en-equiv", "set_right: SUCCESS"),
    test(command, "rose-tree-1.c", "-validate infer/output/sa/rose-tree-1.cp -tp z3 --pred-en-equiv", "check_tree: SUCCESS"),
    test(command, "check-mcf.c", "-validate infer/output/sa/check-mcf.cp -tp z3", "check_child: SUCCESS"),
    test(command, "tll-parent.c", "-validate infer/output/sa/tll-parent.cp -tp z3 --pred-en-equiv", "set_right: SUCCESS")
  )

  val HipVpermTests = List(
    test(command, "vperm/alt_threading.ss", "--ann-vp", "increment: SUCCESS, main: SUCCESS"),
    test(command, "vperm/fibonacci.ss", "--ann-vp -tp z3 -perm none --dis-ls dis--locklevel", "seq_fib: SUCCESS, para_fib2: SUCCESS"),
    test(command, "vperm/global-var-norace.ss", "--ann-vp --dis-pgbv", "inc: SUCCESS, func: SUCCESS"),
    test(command, "vperm/global-var-race.ss", "--ann-vp --dis-pgbv", "inc: SUCCESS, func: FAIL"),
    test(command, "vperm/mergesort.ss", "--ann-vp", "count: SUCCESS, split_func: SUCCESS, merge: SUCCESS, insert: SUCCESS, parallel_merge_sort2: SUCCESS"),
    test(command, "vperm/passive_stack_race.ss", "--ann-vp", "assign: SUCCESS, stack_race: FAIL"),
    test(command, "vperm/stack_race.ss", "--ann-vp", "assign: SUCCESS, stack_race: FAIL"),
    test(command, "vperm/quicksort.ss", "--ann-vp", "partition: SUCCESS, append_bll: SUCCESS, para_qsort2: SUCCESS"),
    test(command, "vperm/task_decompose.ss", "--ann-vp", "inc: SUCCESS, creator: SUCCESS, joiner: SUCCESS, main: SUCCESS"),
    test(command, "vperm/threads.ss", "--ann-vp", "make_tree: SUCCESS, tree_compute_sum_facs: SUCCESS, summator: SUCCESS, start_sum_thread: SUCCESS, join_sum_thread: SUCCESS, main: SUCCESS"),
    test(command, "vperm/tree_count.ss", "--ann-vp", "parallelCount2: SUCCESS"),
    test(command, "vperm/tree_search.ss", "--ann-vp -tp mona -perm none", "para_search2: SUCCESS"),
    test(command, "vperm/vperm_check.ss", "--ann-vp", "inc: SUCCESS, incCell: SUCCESS, test1: FAIL, test2: FAIL, test3: FAIL, test4: FAIL"),
    test(command, "vperm/vperm_simple.ss", "--ann-vp", "foo: SUCCESS, f: SUCCESS, foo2: SUCCESS, f2: SUCCESS")
  )

  val ParahipTests = List(
    test(command, "parahip/simple.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/forkjoin.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/cell.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "test: SUCCESS, test1: FAIL"),
    test(command, "parahip/cell4.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "inc: SUCCESS, main: SUCCESS"),
    test(command, "parahip/cell-lock-vperm.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "testCell: SUCCESS, testVar: FAIL"),
    test(command, "parahip/cell-extreme-cases.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "test: FAIL, test2: FAIL, test3: FAIL, test4: FAIL"),
    test(command, "parahip/ls-bind.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/ls-waitlevel2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func2: SUCCESS, func3: SUCCESS, func4: SUCCESS"),
    test(command, "parahip/double-acquire.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: FAIL"),
    test(command, "parahip/no-deadlock1.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/no-deadlock2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/no-deadlock3.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/deadlock1.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: FAIL"),
    test(command, "parahip/deadlock2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: FAIL"),
    test(command, "parahip/deadlock3.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: FAIL"),
    test(command, "parahip/disj-no-deadlock1.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/disj-no-deadlock2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/disj-no-deadlock3.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/disj-deadlock.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: FAIL"),
    test(command, "parahip/ordered-locking.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: SUCCESS, main: SUCCESS"),
    test(command, "parahip/unordered-locking.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "func: FAIL, main: SUCCESS"),
    test(command, "parahip/multicast.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "initialize: SUCCESS, thread: SUCCESS"),
    test(command, "parahip/oracle.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "thread: SUCCESS, main: SUCCESS"),
    test(command, "parahip/owicki-gries.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "incrementor2: SUCCESS, incrementor1: SUCCESS, main: SUCCESS"),
    test(command, "parahip/fibonacci.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj", "seq_fib: SUCCESS, para_fib: SUCCESS"),
    test(command, "parahip/create_and_acquire.ss", "--en-para -tp parahip --dis-locklevel --en-thrd-and-conj", "create_and_acquire: SUCCESS")
  )

  val HipThreadsTests = List(
    test(command, "threads/motiv-example.ss", "--en-para --en-thrd-resource -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "threads/motiv-example2.ss", "--en-para --en-thrd-resource -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "threads/no-deadlock-nonlexical2.ss", "--en-para --en-thrd-resource -tp parahip --en-lsmu-infer", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "threads/no-deadlock-nonlexical.ss", "--en-para --en-thrd-resource -tp parahip --en-lsmu-infer", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "threads/forkjoin.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/cell4.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "inc: SUCCESS, main: SUCCESS"),
    test(command, "threads/ls-bind.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/no-deadlock1.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/no-deadlock2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/no-deadlock3.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/deadlock1.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: FAIL"),
    test(command, "threads/deadlock2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: FAIL"),
    test(command, "threads/deadlock3.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: FAIL"),
    test(command, "threads/disj-no-deadlock1.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/disj-no-deadlock2.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/disj-no-deadlock3.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/disj-deadlock.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: FAIL"),
    test(command, "threads/ordered-locking.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: SUCCESS, main: SUCCESS"),
    test(command, "threads/unordered-locking.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "func: FAIL, main: SUCCESS"),
    test(command, "threads/oracle.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "thread: SUCCESS, main: SUCCESS"),
    test(command, "threads/owicki-gries.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "incrementor2: SUCCESS, incrementor1: SUCCESS, main: SUCCESS"),
    test(command, "threads/fibonacci.ss", "--en-para -tp parahip --en-lsmu-infer --en-thrd-resource", "seq_fib: SUCCESS, para_fib: SUCCESS")
  )

  val HipVeribsyncTests = List(
    test(command, "veribsync/while-loop.ss", "--en-para -perm bperm -tp redlog", "fun: SUCCESS, fun3: SUCCESS, loop_fun: SUCCESS, loop_fun3: SUCCESS"),
    test(command, "veribsync/while-loop2.ss", "--en-para -perm bperm -tp redlog", "fun: SUCCESS, fun3: SUCCESS, fun4: SUCCESS, fun5: SUCCESS, fun6: SUCCESS, fun7: SUCCESS, fun8: SUCCESS, fun9: SUCCESS"),
    test(command, "veribsync/hip-bperm1.ss", "--en-para -perm bperm -tp redlog", "destroyCellFail: FAIL, readCell: SUCCESS, testNewCell: SUCCESS, testNewCell2: SUCCESS, updateCell: SUCCESS, updateCellFail: FAIL"),
    test(command, "veribsync/bperm-exp.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS, thread3: SUCCESS"),
    test(command, "veribsync/barrier-static-primitives.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS"),
    test(command, "veribsync/barrier-static-exp1.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-static-exp2.ss", "--en-para -perm bperm -tp redlog", "main: FAIL, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-static-exp3.ss", "--en-para -perm bperm -tp redlog", "main: FAIL, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-static-complex.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-static-complex2.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-static-complex3.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread: SUCCESS"),
    test(command, "veribsync/barrier-static-multiple.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, main_fail: SUCCESS, participant: SUCCESS, participant_fail: FAIL"),
    test(command, "veribsync/barrier-static-consistency.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, main_fail: FAIL, participant: SUCCESS, participant1: SUCCESS, participant_fail: FAIL"),
    test(command, "veribsync/barrier-dynamic-exp1.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS, thread3: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp2.ss", "--en-para -perm bperm -tp redlog", "main: FAIL, thread1: SUCCESS, thread2: SUCCESS, thread3: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp3.ss", "--en-para -perm bperm -tp redlog", "main: FAIL, thread1: SUCCESS, thread2: SUCCESS, thread3: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp4.ss", "--en-para -perm bperm -tp redlog", "childthread1: SUCCESS, childthread2: SUCCESS, main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp5.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp6.ss", "--en-para -perm bperm -tp redlog", "main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS"),
    test(command, "veribsync/barrier-dynamic-exp7.ss", "--en-para -perm bperm -tp redlog", "CalculationInTask: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/barnes.ss", "--en-para -perm bperm -tp redlog", "ANLinit: SUCCESS, ComputeForces: SUCCESS, Housekeep: SUCCESS, find_my_bodies: SUCCESS, hackcofm: SUCCESS, maketree: SUCCESS, stepsystem: SUCCESS, find_my_initial_bodies: SUCCESS, SlaveStart: SUCCESS, diagnostics: SUCCESS, initoutput: SUCCESS, initparam: SUCCESS, startrun: SUCCESS, tab_init: SUCCESS, main: SUCCESS, output: SUCCESS"),
    test(command, "veribsync/benchmark/fmm.ss", "--en-para -perm bperm -tp redlog", "MergeLocalGridSize: SUCCESS, DetermineGridSize: SUCCESS, MergeLocalGrid: SUCCESS, ConstructGrid: SUCCESS, ConstructLists: SUCCESS, CostZonesHelper: SUCCESS, CostZones: SUCCESS, ZeroBox: SUCCESS, CreateBoxes: SUCCESS, CreateDistribution: SUCCESS, CreateParticleList: SUCCESS, gets: SUCCESS, GetArguments: SUCCESS, InitExpTables: SUCCESS, InitGlobalMemory: SUCCESS, InitParticleList: SUCCESS, PartitionGrid: SUCCESS, StepSimulation: SUCCESS, generateNumBoxes: SUCCESS, ParallelExecute: SUCCESS, PrintGrid: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/ocean.ss", "--en-para -perm bperm -tp redlog", "gets: SUCCESS, main: SUCCESS, multig: SUCCESS, slave2: SUCCESS, slave: SUCCESS"),
    test(command, "veribsync/benchmark/raytrace.ss", "--en-para -perm bperm -tp redlog", "BuildHierarchy_Uniform: SUCCESS, PrintStatistics: SUCCESS, ReadEnvFile: SUCCESS, ReadGeoFile: SUCCESS, StartRayTrace: SUCCESS, gets: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/volrend.ss", "--en-para -perm bperm -tp redlog", "Compute_Base: SUCCESS, Compute_Normal: SUCCESS, Compute_Octree: SUCCESS, Compute_Opacity: SUCCESS, Init_Decomposition: SUCCESS, Init_Options: SUCCESS, Load_Map: SUCCESS, Load_Normal: SUCCESS, Load_Opacity: SUCCESS, Frame: SUCCESS, Normal_Compute: SUCCESS, Opacity_Compute: SUCCESS, Or_Neighbors_In_Base: SUCCESS, Ray_Trace: SUCCESS, Render: SUCCESS, Render_Loop: SUCCESS, getAdaptive: SUCCESS, getNumNodes: SUCCESS, getRotateSteps: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/water-nsquared.ss", "--en-para -perm bperm -tp redlog", "INTERF: SUCCESS, INTRAF: SUCCESS, POTENG: SUCCESS, PREDIC: SUCCESS, MDMAIN: SUCCESS, WorkStart: SUCCESS, getNPRINT: SUCCESS, getNSAVE: SUCCESS, getNSTEP: SUCCESS, gets: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/water-spatial.ss", "--en-para -perm bperm -tp redlog", "INTERF: SUCCESS, INTRAF: SUCCESS, POTENG: SUCCESS, PREDIC: SUCCESS, MDMAIN: SUCCESS, WorkStart: SUCCESS, getNPRINT: SUCCESS, getNSAVE: SUCCESS, getNSTEP: SUCCESS, gets: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/cholesky.ss", "--en-para -perm bperm -tp redlog", "AssignBlocksNow: SUCCESS, ComputeTargetBlockSize: SUCCESS, PreProcessFO: SUCCESS, Go: SUCCESS, InitOneFreeList: SUCCESS, MallocInit: SUCCESS, ReadSparse: SUCCESS, gets: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/fft.ss", "--en-para -perm bperm -tp redlog", "FFT1DOnce: SUCCESS, FFT1D: SUCCESS, SlaveStart: SUCCESS, gets: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/lu.ss", "--en-para -perm bperm -tp redlog", "lu: SUCCESS, OneSolve: SUCCESS, SlaveStart: SUCCESS, gets: SUCCESS, main: SUCCESS"),
    test(command, "veribsync/benchmark/radix.ss", "--en-para -perm bperm -tp redlog", "getNumProcs: SUCCESS, main: SUCCESS, slave_sort: SUCCESS"),
    test(command, "veribsync/benchmark/radiosity.ss", "--en-para -perm bperm -tp redlog", "init_ray_tasks: SUCCESS, process_tasks: SUCCESS, init_global: SUCCESS, init_visibility_module: SUCCESS, input: SUCCESS, parse_args: SUCCESS, main: SUCCESS, radiosity: FAIL")
  )

  val BagsTests = List(
    test(command, "avl-all-1.ss", "", "remove_min: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, height: SUCCESS"),
    test(command, "avl-all.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, height: SUCCESS"),
    test(command, "avl-modular-2.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, diff_h_by_2: SUCCESS, diff_h_by_1: SUCCESS, eq_h: SUCCESS, less_h: SUCCESS, get_max_height_add1: SUCCESS, height: SUCCESS"),
    test(command, "avl-modular-3.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, height: SUCCESS"),
    test(command, "avl-modular-hei.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, rotate_right2: SUCCESS, rotate_left2: SUCCESS, height: SUCCESS"),
    test(command, "avl-modular-new3.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, is_mem: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, diff_h_by_2: SUCCESS, diff_h_by_1: SUCCESS, eq_h: SUCCESS, less_h: SUCCESS, get_max_height_add1: SUCCESS, height: SUCCESS"),
    test(command, "avl-modular-set.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS"),
    test(command, "avl-modular-siz.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS"),
    test(command, "avl-modular.ss", "", "delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, height: SUCCESS"),
    test(command, "avl.scp.ss", "", "delete: SUCCESS, remove_min: SUCCESS, insert_inline1: SUCCESS, insert_inline: SUCCESS, insert1: SUCCESS, insert: SUCCESS, build_avl2: SUCCESS, build_avl1: SUCCESS, rotate_double_right1: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left1: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right1: SUCCESS, rotate_right: SUCCESS, rotate_left1: SUCCESS, rotate_left: SUCCESS, height1: SUCCESS, height: SUCCESS"),
    test(command, "avl.ss", "", "insert_inline: SUCCESS, insert: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, height: SUCCESS"),
    test(command, "bubble.ss", "", "bsort1: SUCCESS, bubble1: SUCCESS, id1: SUCCESS"),
    test(command, "cll.ss", "", "delete2: SUCCESS, delete: SUCCESS, count: SUCCESS, count_rest: SUCCESS"),
    test(command, "dll.ss", "", "append: SUCCESS, insert: SUCCESS"),
    test(command, "insertion.ss", "", "insertion_sort: SUCCESS, delete: SUCCESS, insert: SUCCESS"),
    test(command, "ll.ss", "", "reverse1: SUCCESS, delete1: SUCCESS, insert: SUCCESS, append: SUCCESS"),
    test(command, "merge-modular.ss", "", "insert1: SUCCESS, merge1: SUCCESS, merge_sort1: SUCCESS, split1: SUCCESS, count1: SUCCESS"),
    test(command, "merge.ss", "", "insert1: SUCCESS, merge1: SUCCESS, merge_sort1: SUCCESS, split1: SUCCESS, count1: SUCCESS"),
    test(command, "qsort.ss", "", "qsort1: SUCCESS, append_bll1: SUCCESS, partition1: SUCCESS"),
    test(command, "rb_bags.ss", "", "insert_1: SUCCESS, del_1: SUCCESS, remove_min_1: SUCCESS, del_2r_1: SUCCESS, del_2_1: SUCCESS, del_3r_1: SUCCESS, del_3_1: SUCCESS, del_4r_1: SUCCESS, del_4_1: SUCCESS, del_5r_1: SUCCESS, del_5_1: SUCCESS, del_6r_1: SUCCESS, del_6_1: SUCCESS, is_black_1: SUCCESS, is_red_1: SUCCESS, case_2r_1: SUCCESS, rotate_case_3r_1: SUCCESS, case_2_1: SUCCESS, rotate_case_3_1: SUCCESS"),
    test(command, "rb.scp.ss", "", "insert_1: SUCCESS, insert: SUCCESS, del_1: SUCCESS, del: SUCCESS, remove_min_1: SUCCESS, remove_min: SUCCESS, del_2r_1: SUCCESS, del_2r: SUCCESS, del_2_1: SUCCESS, del_2: SUCCESS, del_3r_1: SUCCESS, del_3r: SUCCESS, del_3_1: SUCCESS, del_3: SUCCESS, del_4r_1: SUCCESS, del_4r: SUCCESS, del_4_1: SUCCESS, del_4: SUCCESS, del_5r_1: SUCCESS, del_5r: SUCCESS, del_5_1: SUCCESS, del_5: SUCCESS, del_6r_1: SUCCESS, del_6r: SUCCESS, del_6_1: SUCCESS, del_6: SUCCESS, is_black_1: SUCCESS, is_black: SUCCESS, is_red_1: SUCCESS, is_red: SUCCESS, case_2r_1: SUCCESS, case_2r: SUCCESS, rotate_case_3r_1: SUCCESS, rotate_case_3r: SUCCESS, case_2_1: SUCCESS, case_2: SUCCESS, rotate_case_3_1: SUCCESS, rotate_case_3: SUCCESS"),
    test(command, "selection.ss", "", "selection_sort: SUCCESS, delete_min: SUCCESS, find_min: SUCCESS"),
    test(command, "trees.ss", "", "delete1: SUCCESS, remove_min1: SUCCESS, insert1: SUCCESS, flatten1: SUCCESS, append1: SUCCESS")
  )

  val TermTests = List(
    test(command, "e1.ss", "", "loop: SUCCESS"),
    test(command, "ex1.ss", "", "length: SUCCESS, app2: SUCCESS"),
    test(command, "ex10.ss", "", "loop: SUCCESS"),
    test(command, "ex11.ss", "", "bsearch: SUCCESS"),
    test(command, "ex15.ss", "", "loop: SUCCESS, f: SUCCESS"),
    test(command, "ex16.ss", "", "loop: SUCCESS"),
    test(command, "ex2.ss", "", "loop: SUCCESS"),
    test(command, "ex3.ss", "", "loop: SUCCESS"),
    test(command, "ex4.ss", "", "inc_loop: SUCCESS"),
    test(command, "ex5.ss", "", "foo: SUCCESS"),
    test(command, "ex6.ss", "", "Ack: SUCCESS"),
    test(command, "ex7.ss", "", "loop_aux1: SUCCESS, loop_aux: SUCCESS, loop: SUCCESS"),
    test(command, "ex8.ss", "", "loop2: SUCCESS, loop: SUCCESS"),
    test(command, "ex9.ss", "", "loop: SUCCESS"),
    test(command, "mutual.ss", "", "g: SUCCESS, f: SUCCESS"),
    test(command, "benchs/lit/cav08-1.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/cav08-2.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/cav08-3.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/cav08-4.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/cav08-5.ss", "", "loop: SUCCESS, f: SUCCESS"),
    test(command, "benchs/lit/cav08-6.ss", "", "gcd: SUCCESS"),
    test(command, "benchs/lit/dijkstra76-1.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/dijkstra76-2.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/dijkstra76-3.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/pldi06-1.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/pldi06-2.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/lit/pldi06-3.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/lit/pldi06-4.ss", "", "main: SUCCESS, loop: SUCCESS, loop_aux: SUCCESS"),
    test(command, "benchs/lit/pldi06-5.ss", "", "Ack: SUCCESS"),
    test(command, "benchs/lit/popl07-1.ss", "", "loop_1: SUCCESS, loop_2: SUCCESS, loop_3: SUCCESS"),
    test(command, "benchs/lit/popl07-2.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/sas05.ss", "", "loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/lit/sas10-1.ss", "", "f: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/lit/sas10-2.ss", "", "foo: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/lit/sas10-2a.ss", "", "foo: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/lit/sas10-3.ss", "", "main: SUCCESS, foo: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/lit/vcc-1.ss", "", "f: SUCCESS, g: SUCCESS"),
    test(command, "benchs/lit/vmcai05-1a.ss", "", "loop: SUCCESS"),
    test(command, "benchs/lit/vmcai05-1b.ss", "-tp redlog", "loop: SUCCESS"),
    test(command, "benchs/key/AlternatingIncr.ss", "", "increase: SUCCESS"),
    test(command, "benchs/key/AlternDiv-invalid-1.ss", "-tp redlog", "loop: SUCCESS"),
    test(command, "benchs/key/AlternDiv.ss", "-tp redlog", "loop: SUCCESS"),
    test(command, "benchs/key/AlternDivWidening.ss", "-tp redlog", "loop: SUCCESS, loop_aux: SUCCESS"),
    test(command, "benchs/key/AlternDivWide.ss", "", "loop: SUCCESS, loop_aux: SUCCESS"),
    test(command, "benchs/key/AlternKonv.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Collatz.ss", "", "collatz: SUCCESS"),
    test(command, "benchs/key/ComplInterv2.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/ComplInterv3.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/ComplInterv.ss", "-tp z3", "loop: SUCCESS"),
    test(command, "benchs/key/ComplxStruc-may.ss", "", "complxStruc: SUCCESS"),
    test(command, "benchs/key/ComplxStruc2.ss", "", "loop: SUCCESS, complxStruc: SUCCESS"),
    test(command, "benchs/key/ConvLower.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Cousot.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/DoubleNeg.ss", "-tp redlog", "loop: SUCCESS"),
    test(command, "benchs/key/Even.ss", "", "even: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Ex01.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex02.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex03.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex04.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex05.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex06.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex07.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Ex08.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Ex09.ss", "", "half: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Fibonacci.ss", "", "fib: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Flip2.ss", "", "flip: SUCCESS"),
    test(command, "benchs/key/Flip3.ss", "", "flip: SUCCESS"),
    test(command, "benchs/key/Flip.ss", "", "flip: SUCCESS"),
    test(command, "benchs/key/Gauss.ss", "", "sum: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Gcd-may.ss", "", "gcd: SUCCESS"),
    test(command, "benchs/key/Lcm.ss", "", "lcm: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Marbie1.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Marbie2.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/Middle.ss", "", "middle: SUCCESS"),
    test(command, "benchs/key/MirrorIntervSim.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/MirrorInterv.ss", "", "mirrorInterv: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/ModuloLower.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/ModuloUp.ss", "-tp redlog", "up: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/Narrowing.ss", "", "narrowing: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/NarrowKonv.ss", "", "narrowKonv: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/NegPos.ss", "-tp redlog", "loop: SUCCESS"),
    test(command, "benchs/key/Plait-may.ss", "", "plait: SUCCESS"),
    test(command, "benchs/key/Sunset.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/TrueDiv.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/TwoFloatInterv.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/UpAndDownIneq.ss", "", "upAndDown: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/UpAndDown.ss", "", "upAndDown: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/key/WhileBreak.ss", "", "loop: SUCCESS"),
    test(command, "benchs/key/WhileDecr.ss", "", "decrease: SUCCESS"),
    test(command, "benchs/key/WhileIncrPart.ss", "", "increase: SUCCESS"),
    test(command, "benchs/key/WhileIncr.ss", "", "increase: SUCCESS"),
    test(command, "benchs/key/WhileNestedOffset.ss", "", "increase: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/key/WhileNested.ss", "", "increase: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/key/WhilePart.ss", "", "increase: SUCCESS"),
    test(command, "benchs/key/WhileSingle.ss", "", "increase: SUCCESS"),
    test(command, "benchs/key/WhileSum.ss", "", "increase: SUCCESS"),
    test(command, "benchs/key/WhileTrue.ss", "", "endless: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/DivMinus2.ss", "", "main: SUCCESS, div: SUCCESS, minus: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/DivMinus.ss", "", "main: SUCCESS, div: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/DivWithoutMinus.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/Duplicate.ss", "", "main: SUCCESS, round: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/GCD2.ss", "-tp redlog", "main: SUCCESS, gcd: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/GCD3.ss", "", "main: SUCCESS, gcd: SUCCESS, mod: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/GCD4.ss", "", "main: SUCCESS, gcd: SUCCESS, mod: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/GCD5.ss", "-tp redlog", "main: SUCCESS, gcd: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/GCD.ss", "-tp redlog", "main: SUCCESS, gcd: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/LogAG.ss", "", "main: SUCCESS, half: SUCCESS, log: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/LogBuiltIn.ss", "", "main: SUCCESS, log: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/LogIterative.ss", "-tp redlog", "main: SUCCESS, log: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/LogMult.ss", "-tp redlog", "main: SUCCESS, log: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/Log.ss", "", "main: SUCCESS, half: SUCCESS, log: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/McCarthyIterative-may.ss", "", "mcCarthy: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/McCarthyRec.ss", "", "mcCarthy: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/MinusBuiltIn.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/MinusMin.ss", "", "main: SUCCESS, mn: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/MinusUserDefined.ss", "", "main: SUCCESS, gt: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/Mod.ss", "", "main: SUCCESS, mod: SUCCESS, minus: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/PlusSwap.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Aprove_09/Round3.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/AProVE_10/AG313.ss", "", "main: SUCCESS, quot: SUCCESS"),
    test(command, "benchs/aprove/AProVE_11_iterative/RetValRec.ss", "", "main: SUCCESS, ret: SUCCESS, test: SUCCESS"),
    test(command, "benchs/aprove/AProVE_11_iterative/RetVal.ss", "", "main: SUCCESS, ret: SUCCESS, test: SUCCESS"),
    test(command, "benchs/aprove/AProVE11NO/LoopingNonTerm.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/AProVE11NO/NonPeriodicNonTerm2.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/Avg.ss", "", "avg: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/EqUserDefRec.ss", "", "main: SUCCESS, eq: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/Fibonacci.ss", "", "main: SUCCESS, fib: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/LeUserDefRec.ss", "", "main: SUCCESS, le: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/LogRecursive.ss", "-tp redlog", "main: SUCCESS, log: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/Nest.ss", "", "main: SUCCESS, nest: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TerminatiorRec01.ss", "", "main: SUCCESS, f: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TerminatiorRec02.ss", "-tp redlog", "fact: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TerminatiorRec03.ss", "", "f: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TerminatiorRec04-modified.ss", "", "main: SUCCESS, f: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TerminatiorRec04.ss", "", "main: SUCCESS, f: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TimesPlusUserDef.ss", "", "main: SUCCESS, times: SUCCESS, plus: SUCCESS"),
    test(command, "benchs/aprove/BOG_RTA_11/TwoWay.ss", "-tp redlog", "twoWay: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Break.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Continue1.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Continue.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/costa09-example_1.ss", "", "incr: SUCCESS, add: SUCCESS, incr2: SUCCESS, add2: SUCCESS, incr3: SUCCESS, add3: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/costa09-example_2.ss", "-tp redlog", "main: SUCCESS, divBy: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/costa09-example_3.ss", "", "main: SUCCESS, m: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc1-exc.ss", "", "main: SUCCESS, rec_f: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc2-exc.ss", "", "main: SUCCESS, rec_f: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc3-exc.ss", "", "main: SUCCESS, rec_f: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc4-exc.ss", "", "main: SUCCESS, rec_f: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc5-exc.ss", "", "main: SUCCESS, rec_f: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc-exc.ss", "", "main: SUCCESS, rec_f: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc1-no.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc2-no.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc3-no.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc4-no.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc5-no.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Exc-no.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Loop1.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Nested.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/Sequence.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09/TestJulia4.ss", "-tp redlog", "main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Ackermann.ss", "", "main: SUCCESS, ack: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Double-1.ss", "-tp redlog", "test: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Double2-1.ss", "", "main: SUCCESS, test: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Double2.ss", "", "main: SUCCESS, test: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Double3-1.ss", "", "main: SUCCESS, test: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Double3.ss", "", "main: SUCCESS, test: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Double.ss", "-tp redlog", "main: SUCCESS, test: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Factorial.ss", "-tp redlog", "main: SUCCESS, fact: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/FactSumList.ss", "-tp redlog", "doSum: SUCCESS, fact: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/FactSum.ss", "-tp redlog", "doSum: SUCCESS, fact: SUCCESS, main: SUCCESS"),
    test(command, "benchs/aprove/Costa_Julia_09-recursive/Hanoi.ss", "", "main: SUCCESS, sol: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Iterative/NonPeriodic.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Iterative/Test11.ss", "-tp redlog", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Iterative/Test2.ss", "", "main: SUCCESS, iter: SUCCESS, add: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/AckR.ss", "", "main: SUCCESS, ack: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/FibSLR.ss", "-tp redlog", "main: SUCCESS, fib: SUCCESS, doSum: SUCCESS, create: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/HanR.ss", "", "main: SUCCESS, sol: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/Power.ss", "-tp redlog", "power: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/EvenOdd.ss", "", "even: SUCCESS, odd: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/Recursions.ss", "", "main: SUCCESS, rec0: SUCCESS, rec1: SUCCESS, rec2: SUCCESS, rec3: SUCCESS, rec4: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/Test10.ss", "", "main: SUCCESS, rec: SUCCESS, test: SUCCESS, descend: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/Test12.ss", "-tp redlog", "main: SUCCESS, rec: SUCCESS"),
    test(command, "benchs/aprove/Julia_10_Recursive/Test1.ss", "", "main: SUCCESS, rec: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/ChooseLife.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/Choose.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/Continue.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/Loop.ss", "-tp redlog", "main: SUCCESS, test: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_00.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_01.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_02.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_03.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_04.ss", "", "main: SUCCESS, for_1: SUCCESS, for_2: SUCCESS, for_3: SUCCESS, for_4: SUCCESS, for_5: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_05.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_06.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_10.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_11.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_12.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_20.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_21.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_22.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_23.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/NO_24.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/Parts.ss", "", "parts: SUCCESS, main: SUCCESS, for_1: SUCCESS, loop_1: SUCCESS, for_2: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/Julia_11_iterative/Swingers.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA10.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA1.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA4.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA5.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA6.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA7.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA8.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaA9.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB10.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB11.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB12.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB13.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB14.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB15.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB16-loop.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB16.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB17.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB18.ss", "", "main: SUCCESS, loop: SUCCESS, decrease: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB1.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB2.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB3.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB4.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB4-loop.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB5.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB6.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB7.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaB8.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC10-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC11.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC11-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC1.ss", "", "main: SUCCESS, loop_1: SUCCESS, loop_2: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC1-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC2-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC3.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC3-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC4-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC5-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC7-simpl-1.ss", "", "loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC7-simpl-2.ss", "", "loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC7-simpl.ss", "", "loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC7.ss", "", "main: SUCCESS, loop: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC7-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC8-while.ss", "", "main: SUCCESS"),
    test(command, "benchs/aprove/pasta/PastaC9-while.ss", "", "main: SUCCESS")
  )

  val ListsTests = List(
    test(command, "demo.ss", "", "reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS"),
    test(command, "demo2.ss", "", "app_rev: SUCCESS, reverse: SUCCESS, append: SUCCESS"),
    test(command, "err-coq.ss", "", "ret_first2: SUCCESS, ret_first: SUCCESS"),
    test(command, "ll.ss", "", "reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS"),
    test(command, "ll_bak.ss", "", "reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS"),
    test(command, "ll_bak2.ss", "", "reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS"),
    test(command, "ll_bak3.ss", "", "reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS"),
    test(command, "ll_nolists.ss", "", "reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS"),
    test(command, "ll_test1.ss", "", "reverse: SUCCESS"),
    test(command, "ll_test2.ss", "", "delete: SUCCESS"),
    test(command, "ll_test4.ss", "", "test: SUCCESS"),
    test(command, "ll_test5.ss", "", "delete_val: SUCCESS"),
    test(command, "lrev-bug.ss", "", "lrev: SUCCESS"),
    test(command, "lrev.ss", "", "lrev: SUCCESS"),
    test(command, "merge.ss", "", "merge: SUCCESS"),
    test(command, "merge1.ss", "", "merge: SUCCESS"),
    test(command, "merge2.ss", "", "merge: SUCCESS"),
    test(command, "merge3.ss", "", "merge: SUCCESS"),
    test(command, "mk_zero.ss", "", "mk_zero: SUCCESS"),
    test(command, "perm.ss", "", "append: SUCCESS")
  )


  // Duplicate in bags: (avl-modular-2.ss, ) w/ delete: SUCCESS, delete_top: SUCCESS, remove_min: SUCCESS, remove_max_add: SUCCESS, remove_min_add: SUCCESS, insert: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, diff_h_by_2: SUCCESS, diff_h_by_1: SUCCESS, eq_h: SUCCESS, less_h: SUCCESS, get_max_height_add1: SUCCESS, height: SUCCESS
  // Duplicate: (inflist.ss, --en-inf) w/ remove: SUCCESS, append: SUCCESS, fail_remove: FAIL
  // Duplicate: (infll_take.ss, --en-inf) w/ take: SUCCESS
  // Duplicate: (inftree.ss, --en-inf) w/ count: SUCCESS
  // Duplicate: (stream.ss, --en-inf) w/ zip: SUCCESS
  // Duplicate: (inf-ins.ss, --dsd --en-inf) w/ insert: SUCCESS
  // Duplicate: (bubble-inf.ss, --en-inf) w/ id2: SUCCESS, id3: SUCCESS, bubble: SUCCESS, bsort: SUCCESS
  // Duplicate: (vperm/task_decompose.ss, --ann-vp) w/ inc: SUCCESS, creator: SUCCESS, joiner: SUCCESS, main: SUCCESS
  // Duplicate: (parahip/cell.ss, --en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj) w/ test: SUCCESS, test1: FAIL
  // Duplicate: (parahip/cell-extreme-cases.ss, --en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj) w/ test: FAIL, test2: FAIL, test3: FAIL, test4: FAIL
  // Duplicate: (parahip/ordered-locking.ss, --en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj) w/ func: SUCCESS, main: SUCCESS
  // Duplicate: (parahip/unordered-locking.ss, --en-para -tp parahip --en-lsmu-infer --en-thrd-and-conj) w/ func: FAIL, main: SUCCESS
  // Duplicate: (veribsync/hip-bperm1.ss, --en-para -perm bperm -tp redlog) w/ destroyCellFail: FAIL, readCell: SUCCESS, testNewCell: SUCCESS, testNewCell2: SUCCESS, updateCell: SUCCESS, updateCellFail: FAIL
  // Duplicate: (veribsync/barrier-static-consistency.ss, --en-para -perm bperm -tp redlog) w/ main: SUCCESS, main_fail: FAIL, participant: SUCCESS, participant1: SUCCESS, participant_fail: FAIL
  // Duplicate: (veribsync/barrier-dynamic-exp3.ss, --en-para -perm bperm -tp redlog) w/ main: FAIL, thread1: SUCCESS, thread2: SUCCESS, thread3: SUCCESS
  // Duplicate: (veribsync/barrier-dynamic-exp4.ss, --en-para -perm bperm -tp redlog) w/ childthread1: SUCCESS, childthread2: SUCCESS, main: SUCCESS, thread1: SUCCESS, thread2: SUCCESS
  // Duplicate: (avl.ss, ) w/ insert_inline: SUCCESS, insert: SUCCESS, rotate_double_right: SUCCESS, rotate_double_left: SUCCESS, get_max: SUCCESS, rotate_right: SUCCESS, rotate_left: SUCCESS, height: SUCCESS
  // Duplicate: (bubble.ss, ) w/ bsort1: SUCCESS, bubble1: SUCCESS, id1: SUCCESS
  // Duplicate: (cll.ss, ) w/ delete2: SUCCESS, delete: SUCCESS, count: SUCCESS, count_rest: SUCCESS
  // Duplicate: (dll.ss, ) w/ append: SUCCESS, insert: SUCCESS
  // Duplicate: (insertion.ss, ) w/ insertion_sort: SUCCESS, delete: SUCCESS, insert: SUCCESS
  // Duplicate: (ll.ss, ) w/ reverse1: SUCCESS, delete1: SUCCESS, insert: SUCCESS, append: SUCCESS
  // Duplicate: (merge.ss, ) w/ insert1: SUCCESS, merge1: SUCCESS, merge_sort1: SUCCESS, split1: SUCCESS, count1: SUCCESS
  // Duplicate: (qsort.ss, ) w/ qsort1: SUCCESS, append_bll1: SUCCESS, partition1: SUCCESS
  // Duplicate: (selection.ss, ) w/ selection_sort: SUCCESS, delete_min: SUCCESS, find_min: SUCCESS
  // Duplicate: (trees.ss, ) w/ delete1: SUCCESS, remove_min1: SUCCESS, insert1: SUCCESS, flatten1: SUCCESS, append1: SUCCESS
  // Duplicate: (ll.ss, ) w/ reverse: SUCCESS, create_list: SUCCESS, delete_val: SUCCESS, delete: SUCCESS, insert: SUCCESS, get_next_next: SUCCESS, set_null: SUCCESS, set_next: SUCCESS, get_next: SUCCESS, ret_first: SUCCESS, append: SUCCESS
  // Duplicate: (merge.ss, ) w/ merge: SUCCESS
}